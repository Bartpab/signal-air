defmodule SignalNuisanceWeb.Surveillance.Exploitant.DashboardLiveTest do
    use SignalNuisanceWeb.LiveViewConnCase

    @signalement_existant SignalNuisance.Fixture.Signalement.NuisanceOlfactive.existant()

    @fixtures [
      SignalNuisance.Fixture.Signalement.NuisanceOlfactive.nouveau(signaler_par_id: "user:1"),
      SignalNuisance.Fixture.Signalement.NuisanceOlfactive.nouveau(signaler_par_id: "user:2")
    ]

    setup do
      SignalNuisanceWeb.Endpoint.subscribe("global")
      Enum.each @fixtures, &(SignalNuisance.Signalement.créer &1)
    end

    test "nouveau signalement reçu", %{conn: conn} do
        conn = get(conn, Routes.live_path(conn, SignalNuisanceWeb.Surveillance.Exploitant.DashboardLive))
        assert html_response(conn, 200)
      
        {:ok, view, _html} = live(conn)
        SignalNuisanceWeb.Endpoint.broadcast("global", "nouveau_signalement", @signalement_existant)
        
        # Simulate an event to get the result of the broadcast
        assert render_hook(view, :foo) =~ "id=\"signalement_sig123\""
    end

    test "vu les signalements", %{conn: conn} do
      conn = conn 
        |> assign(:client_id, "exploitant:1")
        |> get(Routes.live_path(conn, SignalNuisanceWeb.Surveillance.Exploitant.DashboardLive))
      
        assert html_response(conn, 200)
    
      {:ok, _view, _html} = live(conn)

      [signalement]  = SignalNuisance.Signalement.liste(signaler_par_id: "user:1")
      signalement_id = signalement.id

      assert_receive %Phoenix.Socket.Broadcast{
        topic: "global", 
        event: "vu_par",  
        payload: %SignalNuisance.VueSignalement{
          vu_par_id:  "exploitant:1", 
          signalement_id:  ^signalement_id
        }
      }
  end
end
  